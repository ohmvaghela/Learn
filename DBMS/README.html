<!DOCTYPE html>
<html>
<head>
<title>README.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="introduction">Introduction</h1>
<ul>
<li>Data : Unorganised data with no meaning</li>
<li>Information : Proceesed data so it can have some meaning</li>
<li>DataBase : Place where data can be stored in can be easily sorted, managed, and accessed</li>
<li>DBMS : Set of program to access, add, update and delete data stored</li>
<li>Abstraction : hiding irrelevent data from users so make the usability more simplified</li>
<li>DBMS v/s File System</li>
</ul>
<blockquote>
<p>DMBS is program to handle data not data itself
But nowadays Database and DBMS exists together
DBA - DataBase Administrator
Consistancy Constraints</p>
</blockquote>
<h1 id="three-schema-architecture">Three Schema Architecture</h1>
<ul>
<li>Physical Level</li>
<li>Logical Level</li>
<li>View Level</li>
</ul>
<h2 id="physical-level--internal-level">Physical Level / Internal Level</h2>
<ul>
<li>Lowest level</li>
<li>Physical Schema
<ul>
<li>Tells what data is stored where and how</li>
<li>Eg. Maps, set, stack, Encription, decription, RB tree, N-arry tree etc</li>
<li>Need to design algo to efficiently <b>store and access</b> data</li>
</ul>
</li>
</ul>
<h2 id="logical-level--conceptual-level">Logical Level / Conceptual Level</h2>
<ul>
<li>Describes relationship among the existing data</li>
<li>Users does not need to be aware of Physical schema</li>
<li>DBA, decides what info in DB needs logical level of abstraction</li>
<li>goal : ease to use</li>
<li>DBA(Data Base Administrator)</li>
</ul>
<h2 id="view-level--extranal-level">View Level / Extranal Level</h2>
<ul>
<li>Highest level of abstraction</li>
<li>Used by end-users</li>
<li>This level contains various subschema for various types of users</li>
<li>Also Security mecahnisms are provided to prevet users from accessing certain data</li>
</ul>
<blockquote>
<p>Instance - Collection of information stored in DB at any moment is called an instance in DB</p>
</blockquote>
<blockquote>
<p>Data Model - ways to describe the design of DB at logical level</p>
</blockquote>
<h1 id="database-language">DataBase Language</h1>
<h2 id="ddl-data-defination-language">DDL (Data Defination Language)</h2>
<ul>
<li>Specify database schema. Constraints that must be checked before DB is updated</li>
<li>Used to define and modify structure of database (not modifying data itself)
<ul>
<li>Eg. CREATE TABLE, ALTER TABLE, DROP TABLE, CREATE INDEX, DROP INDEX</li>
</ul>
</li>
</ul>
<h2 id="dml-data-manuplation-language">DML (Data Manuplation Language)</h2>
<ul>
<li>to perform CRUD operations</li>
<li>Involve Insertion, retrival, deletion, updating info stored in DB</li>
<li>Qurey language</li>
<li>Used to manuplate data (CRUD)</li>
</ul>
<h1 id="123-tier-architecture">1,2,3 Tier Architecture</h1>
<ul>
<li>Tire-1
<ul>
<li>All Client Server and Database are on same machine</li>
</ul>
</li>
<li>Tier-2
<ul>
<li>App partitioned into two components one server and client</li>
<li>Client machine sends query to server</li>
</ul>
</li>
<li>Tier-3
<ul>
<li>App is partitioned into 3 components</li>
<li>Client is frontend and dont call DB directly</li>
<li>Client machine sends query to App server and then App server send query to DB to access data</li>
<li>Features : Scalability, Data Integrity, Security</li>
</ul>
</li>
</ul>
<h1 id="er-model">ER model</h1>
<ul>
<li>High level data model, based on preception on real world</li>
<li>It is collection of basic objects called entities and of relationship among them</li>
</ul>
<h1 id="entity-attribute-entity-set">Entity, Attribute, Entity Set</h1>
<img src="ER_model.png" alt="alt text" width="1000"/>
<ul>
<li>Entity
<ul>
<li>An Object that can be distinguised from other objects</li>
<li>Entity can be uniquely defined by Primary Key or Primary attribute</li>
<li>Strong entity : Can be uniquely identified</li>
<li>Weak entity : Can't be uniquely identified, depends on strong key</li>
</ul>
</li>
<li>Entity Set
<ul>
<li>Collection of entities with same type of attributes</li>
</ul>
</li>
<li>Example
<ul>
<li>A student has name, ID, address, phone_no etc
<ul>
<li>Collection of all students is entity set</li>
<li>A student is an entity</li>
<li>name, ID, address etc are attributes</li>
</ul>
</li>
</ul>
</li>
<li>Attributes
<ul>
<li>Properties of entity</li>
<li>Types
<ul>
<li>Simple - Cant be divided furthur</li>
<li>Composite - Can be divided furthur - eg: name- first, middle, last</li>
<li>Single-valued - can only have one value - eg- student ID</li>
<li>Multi-valued - have more then one value - eg- Phone No</li>
<li>Derived - Can be derived from other attribute - eg- Age (can be derived from DOB)</li>
<li>NULL value
<ul>
<li>Maybe &quot;Not Applicable&quot; Eg. middle name</li>
<li>Or maybe &quot;Unknown&quot; to be filled yet or missing</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Relationship
<ul>
<li>Relates two or more entities</li>
<li>Strong Relationship - Between two strong enitity</li>
<li>Weak Relationship - Between one strong and one weak entity</li>
<li>Degree of Relationships
<ul>
<li>Unary - Between only one entity</li>
<li>Binary - Between two entities</li>
<li>Ternary - Between three entities</li>
</ul>
</li>
<li>Mapping cardinality / Cardinality Ratio
<ul>
<li>Number of entities in one entity set related with Number of entities in other entity set</li>
<li>One to One - One entity in a set is only related to one entity in other set Eg. Citized to Addhar Card</li>
<li>One to many - Citizen to Vehicle (One citizen may own many cars, but one car has only one owner)</li>
<li>Many to one - Course to Professor (One prof may take multiple courses, but one course is taken by single prof)</li>
<li>Many to Many - Groceries to Customer (Many customer may buy single grocery, and single customer may buy many grocery)</li>
</ul>
</li>
<li>Participation Constraint
<ul>
<li>Total or Partial</li>
<li>Total Participation - All entities are involved in relationship</li>
<li>Pratial Participation - All entities may not be involved in relationship</li>
<li>Eg. Customer Take Loan
<ul>
<li>All loans are related to a customer No loan can be without customer</li>
<li>All customer may not have taken loan</li>
<li>So &quot;Customer&quot; to &quot;Take&quot; is Partial</li>
<li>&quot;Loan&quot; to &quot;Take&quot; is Total</li>
<li>Weak entity are always in Total participation</li>
<li>Strong entites may or maynot be in Total constraint</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="extended-er-fratures">Extended ER Fratures</h1>
<h2 id="specialization-and-generalisation">Specialization and Generalisation</h2>
<ul>
<li>Splitting entities into sub-entities based on their attributes</li>
<li>Specialisation - Top-Down-Approch</li>
<li>Generalisation - Bottoms-Up-Approch</li>
<li>Denoted by upside-down tirangle</li>
<li>Why
<ul>
<li>Improve blueprint</li>
<li>Remove redundancies</li>
</ul>
</li>
<li>Eg. - Preson entity - Person - Customor - level 1 Subentity 1 - Employee - level 1 Subentity 2 - HR, Developer, HouseKeeping
<blockquote>
<p>Attribute inheritance - Child can access the attributes of parent
Participation inheritance - If parent entity is in relationship with other enitities then child entities are also in realtionship with that entity</p>
</blockquote>
</li>
</ul>
<h2 id="aggrigation">Aggrigation</h2>
<ul>
<li>To show relationship of one entity with multiple entities we need to link multiple entity with relationship</li>
<li>Instead we can do <b>Abstraction</b>
<ul>
<li>Grouping multiple entities and relationships to form a high-level entity, A.K.A <b>Abstract Entity</b></li>
</ul>
</li>
</ul>
<h1 id="relation-model">Relation model</h1>
<ul>
<li>
<p>Data stored in organised tables</p>
</li>
<li>
<p>first ER model is created then relation model is dervied from it</p>
</li>
<li>
<p>All tables have unique name</p>
<pre><code>  - An entity set is a table
  - An entity is called tuple
      - tuple contain the data of all the attribute relatied to that entity
  - Columns represents all the attributes
</code></pre>
</li>
<li>
<p>Example - Table/Entity set - student - Say columns are - Student_Roll_No, Name, DOB, Sex - Tuple/Entity - 19ME02037, Ohm, 1/3/2001, male</p>
<blockquote>
<p>RDBMS - Softwares/Tools to implement DBMS eg. MySQL, MSaccess, Oracle</p>
</blockquote>
<pre><code>    - Degree of table : Number of entites involved in a relation (Unary,Binary,ternary,n-ary)
    - Cardinality : Number of tuple invloved in a relation
</code></pre>
</li>
<li>
<p>Property of relational table</p>
<ul>
<li>Name of relation, column/attribute, values of tuples are distinct</li>
<li>Values are atomic, can't be broken further</li>
<li>Sequencing of rows and columns is insignificant</li>
<li>Tables must follow intigrity constraints</li>
</ul>
</li>
<li>
<p>Relational Key : Set of columns/attributes which can uniquely identify each tuple</p>
</li>
</ul>
<h2 id="relational-model-keys">Relational model Keys</h2>
<pre><code>- SK(Super Key) : P&amp;C of all the attributes in table that can uniquly identify each tuple
- CK(Candidate Key) : (Should not be NULL)minimun subset of SK which can uniquely identify the tuple and dont contain any redundant attribute
- PK(Primary Key) : Selected out set of CK with least number of attributes.
- AK(Alternate Key) : All CK except PK
- FK(Foriegn Key) : Used to create relation between two tables
    - Referenced/Parent table | Referencing/Child table
- Composite Key : PK with least 2 attributes
- Compound Key : PK formed using 2 FK
- Surrogate Key : When two tables are merged so new integer key is generated which may be used as PK
</code></pre>
<blockquote>
<p>CRUD - Create Read Update Delete</p>
</blockquote>
<h2 id="integrity-constraints">Integrity Constraints</h2>
<ul>
<li>
<p>CRUD operations must be done with some integrity policy so they remain consistaint</p>
</li>
<li>
<p>else some querry might corrupt our database</p>
<pre><code>  - Domain Constraint : Resticts value of attributes Eg: name must contain A-Z or age&gt;18
  - Entity Constraint : Pk != NULL
  - Referential Constraint :
      - Insert Constraint : To insert tuple in child table corrosping key value mus be present in parent table
      - Delete Constraint : We cant delete tuple from parent table untill there is a reference(foriegn key) present in child table
      - ON Delete Cascade :- While deleting tuple from parent table all the related tuple with FK of child==PK of parent are also deleted
      Can we have foriegn key with NULL value - YES
      - ON delete NULL :- After deleting tuple from parent table the FK in child table is changed to NULL
  - Key Constraint :
      - NOT NULL :- This attribute cannot have NULL value
      - UNIQUE :- All values in column are unique
      - DEFAULT :- Uses default value for element in table if not specified
      - CHECK :- Integrity constraint, check data integrity before and after CURD
      - PRIMARY KEY :- This attribute/column is set to primary key
      - FORIRGN KEY :- This attribute/column is set to foriegn key
</code></pre>
</li>
</ul>
<h1 id="converting-er-model-to-relational-model">Converting Er model to relational model</h1>
<blockquote>
<p>.</p>
</blockquote>
<h2 id="to-be-written">to be written</h2>
<h1 id="sql">SQL</h1>
<h2 id="sql-vs-mysql-and-others">SQL vs (MySQL, and others)</h2>
<blockquote>
<p>SQL - Structured Query Language</p>
</blockquote>
<ul>
<li>SQL
<ul>
<li>it is a Language</li>
<li>Way to access data</li>
</ul>
</li>
<li>RDBMS
<ul>
<li>MySQL, Oracle, MS access, MySQL server</li>
<li>It is software which used SQL as language</li>
<li>CRUD operations are done on it using SQL</li>
</ul>
</li>
</ul>
<img src="data_types.png" alt="alt text" width="1000"/>
<h2 id="char-vs-varchar">CHAR vs VARCHAR</h2>
<ul>
<li>say we have two command CHAR(255) and VARCHAR(255)</li>
<li>in CHAR(255) the memory for 255 is alloted now and is left empty if not used</li>
<li>while in VARCHAR(255) memory is alloted as it is used</li>
</ul>
<blockquote>
<p>BOOLEAN is stored as TINYINT in SQL</p>
</blockquote>
<blockquote>
<p>By default sorting is ascending</p>
</blockquote>
<h3 id="forigen-key-syntax">FORIGEN KEY syntax</h3>
<ul>
<li>FORIEGN KEY (curr_table_colunm_name) REFERENCES reference_table(PK_in_ref_table)</li>
<li>Eg.
<ul>
<li>&quot;customer&quot; is parent table with PK &quot;Cus_ID&quot;</li>
<li>&quot;product&quot; is child table with &quot;IDC&quot; as foriegn key</li>
<li>Syntax
CREATE TABLE product{
ID INT PRIMARY KEY,
.
.
.
IDC INT,
FORIEGN KEY (IDC) REFERENCES customer(Cus_ID)
}</li>
</ul>
</li>
</ul>
<h3 id="default-constraint">DEFAULT constraint</h3>
<pre><code>CREATE TABLE account
{
    id INT PRIMARY KEY,
    name VATCHAR(100),
    balance INT NOT NULL DEFAULT 0
}
</code></pre>
<blockquote>
<p>can we use &quot;balance INT DEFAULT 0&quot; and skip NOT NULL</p>
</blockquote>
<blockquote>
<p>DESC student -- table column datatypes</p>
</blockquote>
<blockquote>
<p>using change we can edit name of column as well as data type of column</p>
</blockquote>
<h2 id="what-are-jsonjavascript-object-notation-file">What are JSON(JavaScript Object Notation) file?</h2>
<blockquote>
<p>.</p>
</blockquote>
<h2 id="dml-data-manuplation-language">DML (Data Manuplation Language)</h2>
<pre><code>CREATE TABLE customer
{
    id INT PRIMARY KEY UNIQUE,
    name varchar(255) UNIQUE,
    address varchar(255),
    gender char(2) -- M,F
    city varchar(255),
    pincode INT
}
</code></pre>
<h4 id="insert">INSERT</h4>
<pre><code>    INSERT INTO customer(id,name,address,gender,city,pincode)
    VALUES  (123,'ohm','somewhere in surat','M','surat','395009'),
            (134,'Aohm','Asomewhere in surat','M','Asurat','395009');

    INSERT INTO customer VALUES
    (123,'ohm','somewhere in surat','M','surat',395009),
    (134,'Aohm','Asomewhere in surat','M','Asurat',395009);
</code></pre>
<h4 id="update">UPDATE</h4>
<blockquote>
<p>if PK don't exist then no change will be done</p>
</blockquote>
<pre><code>- Single row

        UPDATE customer SET address='mumbai', pincode=702520 WHERE id=123;

- Multiple Rows

        -- In MySQL there is security so it wont allow this operation
        UPDATE custormer SET pincode=702520;

        -- First we will disable security then we can do the same
        SET SQL_SAFE_UPDATES = 0;
        UPDATE custormer SET pincode=702520;
        UPDATE custormer SET id=id+2;

        -- Then we will again enable security
        SET SQL_SAFE_UPDATES = 1;
</code></pre>
<h4 id="delete">DELETE</h4>
<pre><code>    DELETE FROM customer WHERE id=123;
    -- safe mode again applies over here
</code></pre>
<ul>
<li>
<p>ON DELETE CASCADE/ SET NULL</p>
<pre><code>  CREATE TABLE customer
  {
      id INT PRIMARY KEY UNIQUE,
      name varchar(255) UNIQUE,
      address varchar(255),
      gender char(2) -- M,F
      city varchar(255),
      pincode INT,
      -- person - table | P_pincode - column in person table
      FORIEGN KEY(pincode) references preson(P_pincode) ON DELETE SET NULL,
      -- similarly for CASCADE
      -- FORIEGN KEY(pincode) references preson(P_pincode) ON DELETE CASCADE,
  }
</code></pre>
</li>
</ul>
<h4 id="replace">Replace</h4>
<p><code>STEP 1 - if PK exists so deletes data</code></p>
<p><code>STEP 2 - adds new data anyways even if PK dont exists</code></p>
<pre><code>    REPLACE INTO customer VALUES
    (134,'Aohm','Asomewhere in surat','M','Asurat','395009');

    REPLACE INTO customer SET id=134, ciy='surat';

    -- set all other values to NULL
    -- so all other values except pincode,city and id must have default value or shall be NULL
    REPLACE INTO customer(pincode,city)
        SELECT pincode, city
        FROM customer WHERE id=123;
</code></pre>
<h4 id="over-partition-by">OVER PARTITION BY</h4>
<pre><code>    --syntex
    Entity OVER (PARTITION BY columns ORDER BY columns) AS X

    CREATE TABLE sales
    {
        sale_id VARCHAR(100),
        sale_date DATE,
    }

    SELECT  sale_day,
            EXTRACT ('month' FROM sale_date) AS MONTH,
            SUM(quantity) OVER (PARTITON BY sale_id) AS total_unit_sold_per_id,
            SUM(quantity) OVER (PARTITON BY sale_id,YEAR) AS total_unit_sold_per_id_per_year,
            SUM(quantity) OVER (PARTITON BY sale_id,MONTH) AS total_unit_sold_per_id_per_month
    FROM sales
    WHERE EXTRACT ('year' FROM sale_date) AS YEAR
    ORDER BY sale_id;
</code></pre>
<h4 id="rownumber">ROW_NUMBER</h4>
<p><code>To give row number to all entites in perticular window</code></p>
<pre><code>--syntex
ROW_NUMBER() OVER(PARTITION BY COLUMN ORDER BY COLUMN) AS RN

CREATE TABLE employee
{
    id INT,
    name VARCHAR(100),
    dep_name VARCHAR(100),
    salary INT
};

-- RN starts from 1 and it will show first 2 id from each department
SELECT  * FROM (
    SELECT e.*,
    ROW_NUMBER() OVER(PARTITION BY dep_name ORDER BY id) AS rn
    FROM employee AS e
) AS rn
WHERE rn &lt; 3;
</code></pre>
<h4 id="rank">RANK</h4>
<p><code>To give rank to all entites belong to same group</code></p>
<pre><code>--syntex
RANK() OVER(PARTITION BY COLUMN ORDER BY COLUMN) AS RK

CREATE TABLE employee
{
    id INT,
    name VARCHAR(100),
    dep_name VARCHAR(100),
    salary INT
};

-- RK starts from 1 and it will give same rank if value is same
-- Eg. 1,2,2,4,5,6,6,7...
SELECT e.* FROM
RANK() OVER(PARTITION BY dep_name ORDER BY salary desc) as rnk
FROM employee AS e;
</code></pre>
<p><code>RANK and DENSE_RANK as be used interchangably but results will differ as shown</code></p>
<p><code>RANK       1,2,2,4,5,6,6,8,9,10</code></p>
<p><code>DENSE_RANK 1,2,2,3,4,5,6,6,7,8</code></p>
<p><code>Percent rank is used to compare the elements w.r.t first element</code></p>
<h4 id="laglead">LAG/LEAD</h4>
<p><code>Used to compare value with previous(LAG) or next(LEAD) row </code></p>
<pre><code>-- syntex
LAG(column,NTH_PREV_ROW,DEFAULT_VAL) OVER(PARTITION BY column ORDER BY column)
LAG(column,NTH_NEXT_ROW,DEFAULT_VAL) OVER(PARTITION BY column ORDER BY column)

CREATE TABLE employee
{
    id INT,
    name VARCHAR(100),
    dep_name VARCHAR(100),
    salary INT
};

select e.*,
LAG(salary) OVER(PARTITION BY dep_name ORDER BY id) AS prev_sal,
LEAD(salary) OVER(PARTITION BY dep_name ORDER BY id) AS next_sal,
FROM employee AS e;
-- Here by default NTH_PREV_ROW,NTH_NEXT_ROW are set to 1, and DEFAULT_VAL to NULL
</code></pre>
<h4 id="case">CASE</h4>
<p><code>if statement</code></p>
<pre><code>SELECT e.*,
CASE    WHEN CONDITION1 OVER(PARTITION BY column ORDER BY column) THEN 'show this string in table',
        WHEN CONDITION2 OVER(PARTITION BY column ORDER BY column) THEN 'show this string in table',
        .
        .
        .
        WHEN CONDITION3 OVER(PARTITION BY column ORDER BY column) THEN 'show this string in table',
        WHEN CONDITION4 OVER(PARTITION BY column ORDER BY column) THEN 'show this string in table',
END AS case_column
FROM employee as e;
</code></pre>
<h4 id="firstvallastvalnthval">FIRST_VAL,LAST_VAL,NTH_VAL</h4>
<p><code>Form new table with FIRST_VAL, LAST_VAL or NTH_VAL</code></p>
<pre><code>-- syntax
FIRST_VAL(COLUMN) OVER(PARTITION BY column ORDER BY column) AS fv
LAST_VAL(COLUMN) OVER(PARTITION BY column ORDER BY column) AS lv
NTH_VAL(COLUMN,NTH) OVER(PARTITION BY column ORDER BY column) AS nv
</code></pre>
<h3 id="questions">Questions</h3>
<p><code>From a table of employees miscalculated salary is without using zeros </code></p>
<p><code>Find average salaray - miscalculated average salary</code></p>
<p><code>if sal = 10012 :- Miscalculated is 112</code></p>
<pre><code>SELECT AVG(SALARY) - AVG(RELPACE(SALARY,'0','')) FROM EMPLOYEES
</code></pre>
<p><code>Find max package and number of employee with max pkg (pkg = salary*months)</code></p>
<pre><code>SELECT (months*salary) as pkg, COUNT(*) FROM Employee GROUP BY pkg ORDER BY pkg DESC LIMIT 1;

-- Here 'group by' and 'order by' have same arguments but they can differ when the entity to sorted is single and not group as shown here
-- SELECT (months*salary) as pkg, COUNT(*) FROM Employee GROUP BY pkg ORDER BY salary DESC LIMIT 1;
-- The above query in code will give error
</code></pre>
<h1 id="joins">JOINS</h1>
<ul>
<li>To disply data from two tables combined</li>
<li>A relation must exist a relation between two tables</li>
<li>Here in 'CONDITION' matching refers to matching FROIEGN KEY</li>
</ul>
<blockquote>
<p>'AS' is used so now</p>
<blockquote>
<p>customer can be written as 'c' and</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>order can be written as 'o'</p>
</blockquote>
</blockquote>
<ul>
<li>
<p>INNER JOIN
<code>Intersection of two tables</code></p>
<pre><code>    SELECT c.*, o.* FROM customer AS c INNER JOIN order as o c.id
</code></pre>
</li>
<li>
<p>OUTER JOIN</p>
<ul>
<li>
<p>Intersection + data from either left right or both table`</p>
</li>
<li>
<p>say table L and R</p>
</li>
<li>
<p>L+(L ∩ R) | R+(L ∩ R) | L ∪ R</p>
</li>
<li>
<p>Left Table (full customer table and intersection of order table)
SELECT c.<em>, o.</em> FROM customer AS c LEFT JOIN order as o ON c.id</p>
</li>
<li>
<p>Right Table (full order table and intersection of customer table)</p>
<pre><code>  SELECT c.*, o.* FROM customer AS c RIGHT JOIN order as o ON c.id
</code></pre>
</li>
<li>
<p>CROSS JOIN</p>
<blockquote>
<p>Cross Join (all possible FK combinations if any exist will be displayed in table)</p>
</blockquote>
<pre><code>    SELECT c.*, o.* FROM customer AS c FULL JOIN order as o;
</code></pre>
</li>
<li>
<p>SELF JOIN</p>
<pre><code>  SELECT c1.id,c2.id,c2.pincode
  FROM customer AS c1
  INNER JOIN customer AS c2
  ON c1.id = c2.id
</code></pre>
</li>
<li>
<p>UNION</p>
<pre><code>  SELECT city FROM customer
  UNION
  SELECT id FROM Orders
  ORDER BY id;

  SELECT city FROM customer
  UNION ALL
  SELECT pincode FROM order
  ORDER BY id;

  SELECT City,Address FROM customer WHERE pincode=395009
  UNION
  SELECT city, address FROM order WHERE pincode=750520
  ORDER BY address;
</code></pre>
</li>
</ul>
</li>
</ul>
<h1 id="normalisation">Normalisation</h1>
<ul>
<li>Used to optimse DB</li>
<li>Functional Dependency (FD)
<ul>
<li>When one attribute is used to determine other attribute the dependency is called FD</li>
</ul>
</li>
<li>&quot;A --&gt; B &quot; A is Determinant and B is Dependent</li>
<li>Types of FD
<ul>
<li>Trivial FD
<ul>
<li>For a FD &quot;A --&gt; B&quot; B is subset of A</li>
</ul>
</li>
<li>Non-Trivial FD
<ul>
<li>For a FD &quot;A --&gt; B&quot; B is not subset of A</li>
</ul>
</li>
</ul>
</li>
<li>Rules of FD
<ul>
<li>Reflexive : If B is subset of A then &quot;A --&gt; B&quot;</li>
<li>Augmentation : Adding a function to FD wont change it Eg. if &quot;A--&gt;B&quot; then &quot;AX--&gt;BX&quot;</li>
<li>Transitivity : If A--&gt;B and B--&gt;C then A--&gt;C</li>
</ul>
</li>
<li>Normalisation
<ul>
<li>Decompose table to remove redundancies from table</li>
<li>Types of Redundancies / Anomalies
<ul>
<li>Insertion : When certain data cannot be added without presence of other data</li>
<li>Deletion, Updation : The following operations may result in unintentional data loss or data inconsistancy</li>
</ul>
</li>
</ul>
</li>
<li>Normal Forms
<ul>
<li>1NF
<ul>
<li>All attributes mush have values which are atomic and single-valued</li>
</ul>
</li>
<li>2NF
<ul>
<li>1NF + All non-prime attributes must be fully dependent on prime attribute</li>
<li>if PK {A,B} | other Key {C,D} so</li>
<li>Valid - (A,B--&gt;C and A,B--&gt;D)</li>
<li>InValid - (B--&gt;C) || (A--&gt;D)</li>
</ul>
</li>
<li>3NF
<ul>
<li>No Transitivity</li>
</ul>
</li>
<li>BCNF(Boyce-Codd normal form)
<ul>
<li>No attribute should define PK</li>
</ul>
</li>
<li>For 1,2,3NF we directly decompose i.e. split table into two with one common PK</li>
<li>For BCNF we add new key while dividing table</li>
</ul>
</li>
</ul>
<h1 id="transaction">Transaction</h1>
<ul>
<li>A unit work done in DB in logical sequence</li>
<li>Each step is logical step like read,write, a = a-b etc.</li>
<li>The result of these statements are complete succes or compete failure
<ul>
<li>If sucess then changes in DB are commited</li>
<li>else if failure occur at any step so all the steps are reverted</li>
</ul>
</li>
</ul>
<h1 id="acid-properties">ACID properties</h1>
<ul>
<li>A transaction must follow ACID properties to ensure integrity of data</li>
<li>Atomicity : Either all operations are refected in DB correctly or none are if any operation is incorrect</li>
<li>Consistency : Integrity constraints are maintained before and after every transactions</li>
<li>Isolation : All the transactions must be isolated.
<ul>
<li>i.e if multiple transactions are required on an account so first one transaction is completely finished and then next is done</li>
<li>Thus it is ensured one transation wont iterfer with other</li>
</ul>
</li>
<li>Durability : After all transactions are complete changes must presist to DB even if there is an system failure</li>
</ul>
<h1 id="transition-state">Transition state</h1>
<img src="transaction_states.png" alt="alt text" width="1000"/>
<ul>
<li>Active State
<ul>
<li>First all basic operations are performed like read/write</li>
<li>If they are successful then state is changes to partically committed state</li>
<li>If anyone fails then state is changes to failed state</li>
</ul>
</li>
<li>Partially Committed State
<ul>
<li>Now all the changes are in buffer if they all are implemened so state is changed to committed state</li>
<li>if it fails to commit change then it is shifted to failed state</li>
</ul>
</li>
<li>Committed State
<ul>
<li>Here the premanent changes are made to DB and rollback cannot be done</li>
<li>Here after DB is updated and terminated state is achived</li>
</ul>
</li>
<li>Failed state
<ul>
<li>When transaction is being implemented and some failure is occured so this state is reached and transaction cant be carried forward so all the changes are rolled back and aborted state is reached</li>
</ul>
</li>
<li>Aborted state
<ul>
<li>After Transaction is rolled back and all the changes are reverted, DB's prior state(state before starting of transaction) is reached.</li>
</ul>
</li>
<li>Terminated state
<ul>
<li>Transaction is either said to commited or aborted in this stage</li>
</ul>
</li>
</ul>
<h1 id="implementing-atomicity-and-durability">Implementing Atomicity and Durability</h1>
<ul>
<li>It is done by &quot;Recovery Mechanism Component&quot; of DBMS</li>
</ul>
<ol>
<li>Shadow Scheme
<ul>
<li>Based on making copies of DB</li>
<li>Say we have a <code>old copy</code> of DB and There is a pointer <code>DB pointer</code> pointing to it</li>
<li>A <code>new copy is made in RAM</code>, all changes are made this new copy of RAM and once they are completed <code>DB pointer</code> now points at this new copy</li>
<li>Atomicity : The DB is either old or new, there is no intermediate DB</li>
<li>Durability : Even if system fails the DB pointer points to new DB</li>
<li><code>COMMITTED</code> status is to be said when DB-pointer points to new DB</li>
<li>Then old copy is deleted</li>
</ul>
</li>
<li>Log based recovery scheme
<ul>
<li>Instead of making a copy of entite DB, which is storage and time consuming we store logs</li>
<li>Before processing any step log is made
<ol>
<li>Deferred DB modification
<ul>
<li>First all the changes are made in log then they are implemented in DB</li>
<li>If log fails at any instence so the updated logs are discarded</li>
<li>Atomicity : If committed status is reached in log then the entire transaction(changes in DB) are implemented or no change is implemented if log fails at any instence</li>
<li>Durability : If DB fails at any instance and the committed status is reached in log commands are performed again based on progess in log</li>
</ul>
</li>
<li>Immediate DB modification
<ul>
<li>Here after each upadte in log change is DB is made</li>
<li>If Transaction fails so changes are revered based on log</li>
</ul>
</li>
<li>
<h2 id="checkpoint-db-modification">Checkpoint DB modification</h2>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<h1 id="indexing">Indexing</h1>
<ul>
<li>Done to optimise performance
<blockquote>
<p>Binary Searching is done sorted data</p>
</blockquote>
</li>
<li>Index is a type of data structure which is used to locate and access the data quickly from DB
<blockquote>
<p>Index files are always sorted</p>
</blockquote>
</li>
<li>Methods : Primary Indexing(Sorted data) | Secoundary Indexing(Unsorted data)</li>
<li>Primary Indexing / Clustering index
<ul>
<li>Indexing is usually done using primary key (however other candidate key may also be used)
<ol>
<li><code>Sparse Indexing</code>/ Indexing Based on <code>Key attribute</code>
<ul>
<li>As the data is sorted based on primary key so key of starting of data block is stored rather then whole data</li>
<li>
<img src="sparse_indexing.png" alt="alt text" width="500"/>
</li>
<li>So in index file only 1,11,21,.... are stored instead of whole DB from 1,2,3,4....</li>
</ul>
</li>
<li><code>Dense Indexing</code>/ Indexing based on <code>Non-Key attribute</code>
<ul>
<li>When we are using non-primary key for indexing there may be multiple entries of same key</li>
<li>So we store every search key value corrosponding to DB</li>
<li>
<img src="dense_indexing.png" alt="alt text" width="500"/>
</li>
</ul>
</li>
<li>Multi-level Indexing
<ul>
<li>Above the indexing is done once here it is done multiple time</li>
<li>
<img src="multi_level_indexing.png" alt="-" width="500" height="400"/>
</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li>Secondary Indexing / Non-Clustering index
<ul>
<li>Indexing done on unsorted data</li>
<li>Here index table contain same number of entries as that in DB</li>
<li>Here in the index table the keys are sorted and pointed to DB where that key is stored in DB</li>
<li>Now primary indexing can be on the index formed from Secondary Indexing</li>
<li>
<img src="secondary_indexing.png" alt="" width="500"/>
</li>
</ul>
</li>
</ul>
<h1 id="nosql-not-only-sql">NoSQL (Not Only SQL)</h1>
<ul>
<li>DB that stores data differently then relational table</li>
<li>data is stored in JSON format file (JavaScript Object Notation)
<ul>
<li>Here all data of entity is stored in file unlike having different tables in SQL</li>
<li>So relationships are avoided</li>
</ul>
</li>
<li>Flexible Schema, easily scalable and can handle big data</li>
<li>Ease of storing unstructured data</li>
<li>History
<ul>
<li>Memory/storage device became cheaper and fast processing became must</li>
<li>So there are redundancies in data at the cost of processing</li>
<li>Popular application : Cloud Computing</li>
</ul>
</li>
<li>Advantages
<ul>
<li>Flexible Schema : Changing schema is easy</li>
<li>Horizontal Scaling : Easier reason being they are self contained and not coupled in relationship
<ul>
<li>Sharding or Replica-sets</li>
</ul>
</li>
<li>High availability
<ul>
<li>Data replica is stored accross multiple server</li>
<li>If one server fails data is safe in other server</li>
</ul>
</li>
<li>Easy insertion and read
<ul>
<li>In SQL data is normalized so data related to one enity is stored accross multiple tables and many join operations are applied at time</li>
<li>This join are expensive</li>
<li>But in NoSQL data related to one entity is stored in single JSON file hence easy access</li>
</ul>
</li>
<li>Caching Mechanism</li>
</ul>
</li>
<li>When to use NoSQL
<ul>
<li>Fast development (No ER or relationship model is requied to develop)</li>
<li>Where data is semi-structured and unstructured</li>
<li>Huge volumes of data and fast access</li>
<li>Scaling is required</li>
<li>Real time streaming, micro-service</li>
</ul>
</li>
<li>Misconceptions
<ul>
<li>NoSQL can store relational DB as well (There are different types of schema in NoSQL)</li>
<li>most NoSQL follow ACID properties</li>
</ul>
</li>
<li>Types of NoSQL
<ol>
<li>Key Value store
<ul>
<li>Stores data in key-value pairs(Only two per file)</li>
<li>Uses
<ul>
<li>Real time random data access : Gaming, Finance</li>
<li>Application designed for simple queries</li>
</ul>
</li>
<li>
<img src="key_value_pair.png" width="500"/>
</li>
</ul>
</li>
<li>Column Oriented/ Columnar/ C-Store/ Wide Column
<ul>
<li>Data is stored column wise say we have employee, salary, age so first row will have all name, second salary, and third age</li>
<li>So unwanted data access can be avioded</li>
<li>Used for analytics</li>
<li>
<img src="columnar_db.png" width="500"/>
</li>
</ul>
</li>
<li>Document Based Store
<ul>
<li>BJSON(Binary JSON)</li>
<li>Contain pair of 'field : value' objects</li>
<li>MongoDB uses this</li>
<li>
<img src="document_db.svg" width="500"/>
</li>
</ul>
</li>
<li>Graph Based Store
<ul>
<li>Each element is called node, and connection is called relationship</li>
<li>In enitre app only some type of data is stored in graph based store
<ul>
<li>Eg. Friends in Facebook, Fraud detection</li>
</ul>
</li>
<li>
<img src="graph_db.png" width="500"/>
</li>
</ul>
</li>
</ol>
</li>
<li>Disadvantages
<ul>
<li>Data redundancies</li>
<li>Upadte and Delete are costly</li>
<li>Does not support data entry with consistency constraint</li>
</ul>
</li>
</ul>
<h2 id="ormobject-relational-mapping">ORM(Object Relational Mapping)</h2>
<ul>
<li>Way to create <code>bridge</code> between object-oriented program and relational DB</li>
<li>Technique used to query and manuplate data easily</li>
<li>Increase readablility</li>
<li>Protection against SQL injections</li>
</ul>
<h1 id="types-of-databases">Types of Databases</h1>
<ol>
<li>
<p>Relational Database</p>
<ul>
<li>Stores data in tables</li>
<li>A.K.A RDBMS</li>
<li>Highly optimised DB, no redundancies</li>
<li>When data become huge system become more complex</li>
<li>Scalabilty issue (Horizontal scaling not fesible)</li>
</ul>
</li>
<li>
<p>Object Oriented Database</p>
<ul>
<li>Based on OOPs</li>
<li>Maintaining relations in huge DB can be complex</li>
<li>All data is treated as objects</li>
<li>Advantage
<ul>
<li>Quick data storage and retrieval</li>
<li>Can handle complex data</li>
</ul>
</li>
<li>Disadvantage
<ul>
<li>High complexicity data can cause preformance issues like read, and update can become slow</li>
<li>Dosen't support view in DB</li>
</ul>
</li>
</ul>
</li>
<li>
<p>NoSQL Database</p>
</li>
<li>
<p>Hierarchical Database</p>
<ul>
<li>Data stored in hierarchical order</li>
<li>A parent may have several child</li>
<li>Useful for Disk storage</li>
<li>Only problem is relations can only be 1:n and can't be m:n</li>
<li>Top to bottom search takes time</li>
</ul>
</li>
<li>
<p>Network Database</p>
<ul>
<li>Like Hierarchical DB but can have m:n relations</li>
<li>Data is in Graph data structure, cant handle complex DB</li>
<li>Read and wirte are time consuming</li>
</ul>
</li>
</ol>
<blockquote>
<p>Mostly used DB are Relational DB and NoSQL</p>
</blockquote>
<h1 id="clustering">Clustering</h1>
<ul>
<li>Millions of request made to DB every single second and one server may or may not be able to handle it</li>
<li>So replica of server is made so number of requests can be divided per server</li>
<li>Advantages - Data Redundancy : In case of one server fails others are still active - Load Balancing : If one server is having high amount of traffic some traffic is diverted to other server - High availability : If one server shuts other is available and if one server is at high load we have other server
<blockquote>
<p>load balancer diviedes requests based on server load</p>
</blockquote>
</li>
</ul>
<h2 id="pratitioning--sharding">Pratitioning &amp; Sharding</h2>
<ul>
<li>Dividing and storing data in seperate servers</li>
<li>Vertical Partitioning
<ul>
<li>Slicing Vertically</li>
<li>For getting a complete tuple different servers may need to be accessed</li>
</ul>
</li>
<li>Horizontal Partitioning
<ul>
<li>Slicing row wise</li>
<li>Independent data chunks can be stored in different servers</li>
</ul>
</li>
<li>Routing Layer
<ul>
<li>To split request we need a routing layer so send request to desired server</li>
</ul>
</li>
<li>Advantage
<ul>
<li>Parallelism : For different data different servers are accessed.</li>
<li>Availability : If one server is down other server is there</li>
<li>Performance : Less traffic per server</li>
<li>Managebility : Say we need to edit data for a region say India amazon server so can be done easily</li>
<li>Reduce cost of scaling</li>
</ul>
</li>
<li>Disadvantage
<ul>
<li>For analytics purpose not suitable coz entire data is required which may be stored in different servers</li>
<li>Complex routing layer may be required for complex data relations</li>
</ul>
</li>
</ul>
<blockquote>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Partitioning</th>
<th>Sharding</th>
</tr>
</thead>
<tbody>
<tr>
<td>Scope</td>
<td>Within a single database instance</td>
<td>Across multiple database instances</td>
</tr>
<tr>
<td>Performance improvement</td>
<td>Improved performance for queries that only need to access a subset of the data</td>
<td>Improved performance for all queries, especially those that access large amounts of data</td>
</tr>
<tr>
<td>Scalability improvement</td>
<td>Limited by the capacity of a single database instance</td>
<td>Can scale horizontally by adding more database instances</td>
</tr>
<tr>
<td>Complexity</td>
<td>Less complex than sharding</td>
<td>More complex than partitioning, requires managing multiple database instances</td>
</tr>
</tbody>
</table>
</blockquote>
<blockquote>
<h2 id="partitioning-vs-indexing-in-dbms">Partitioning v/s Indexing in DBMS</h2>
<ul>
<li>Indexing creates a data structure that allows the database to quickly locate specific rows in a table</li>
<li>where as Partitioning divides a table into smaller, more manageable units (partitioning dont create new data structure)</li>
</ul>
</blockquote>
<h1 id="db-scaling">DB scaling</h1>
<h2 id="pattern-1">Pattern 1</h2>
<p><code>Query Optimisation and connection pool</code></p>
<ul>
<li><code>Cache frequently used</code> and <code>non-dynamic</code> data
<ul>
<li>Eg. Ola booking service past booking is non-dynamic data and can be cached</li>
<li>While ride's position is dynamic and needs to feched from server</li>
</ul>
</li>
<li>Introducing Data redundancy(NoSQL)
<ul>
<li>Multiple server etc.</li>
</ul>
</li>
<li>Use connection pool libaries to <code>Cache DB connections</code>
<ul>
<li>Say in a code connection is establised multiple times for different purposes</li>
<li>So we save the connection till current session</li>
</ul>
</li>
</ul>
<h2 id="pattern-2">Pattern 2</h2>
<p><code>Vertical Scaling / Scaling-up</code></p>
<ul>
<li>Upgrading machine i.e. RAM-2x SSD-3x</li>
</ul>
<h2 id="pattern-3">Pattern 3</h2>
<p><code>Command Query Response Segregation (CQRS)</code></p>
<ul>
<li>Seperate <code>Read</code> and <code>Write</code> operations</li>
<li>Master machine handles <code>Write</code> request and replica machine <code>Read</code> operations</li>
<li>Due to this there is <code>lag</code> due to time required by replica machine to update data from Master machine.
<ul>
<li><code>lag</code> is always there but it must be acceptably low</li>
<li>Eg. While ordering from zomato the driver's location is updated after every 1sec and not instantinously and this is acceptable lag for this case</li>
</ul>
</li>
</ul>
<h2 id="pattern-4">Pattern 4</h2>
<p><code>Multiple primary replica</code></p>
<ul>
<li>Multiple replica's are made but here instead of Master-Replica all the machines are Master</li>
<li>And an update cycle is running say we have a,b,c,d server.
<ul>
<li>a --&gt; take update from b server</li>
<li>similarly b --&gt; c, c--&gt;d, d--&gt;a</li>
<li>
<img src="multi_primary_replication.png" width="300"/>
</li>
</ul>
</li>
<li>Even here there is lag, but load is decreased</li>
</ul>
<h2 id="pattern-5">Pattern 5</h2>
<p><code>Partition by data functionaliy</code></p>
<ul>
<li>Here data is divided, and stored in seperate place</li>
<li>Now when request is made so there is a layer which brings data from <code>multiple seperate DB</code> and performs <code>join</code> operation and returns result</li>
<li>Eg. say in OLA
<ul>
<li>after booking ride the user may or maynot check the driver's location</li>
<li>But driver's location needs to be updated and the ride start, end location, payment method, driver's details etc... are constant</li>
</ul>
</li>
<li>So we can save driver's location data and other details in seperate loaction. This pratition be data functionality</li>
<li>And for communication between server <code>Multiple primary replica</code> or <code>primary replica(CQRS)</code> can be done</li>
</ul>
<h2 id="pattern-6">Pattern 6</h2>
<p><code>Horizontal Scaling/ Scale-Out</code></p>
<ul>
<li>Type of sharding where each set of data is called shard.</li>
<li>A machine stores all the related data.</li>
<li>A new layer needs to added which can assemble or say jon all the data before returning.</li>
<li>Eg. Say in a bank one branch deals with all savings account and other branch deals with current account,
<ul>
<li>so we can seperate data of both type of customer so accessing data becomes fast</li>
</ul>
</li>
</ul>
<h2 id="pattern-7">Pattern 7</h2>
<p><code>Data Center wise partitioning</code></p>
<ul>
<li>Say on expanding business in another country the data sent from host country will have high latency</li>
<li>To avoid this we setup another DB in new country</li>
</ul>
<h1 id="cap-theorm">CAP theorm</h1>
<ul>
<li>Parameters to <code>optimise</code> --&gt; <code>distributed DB</code>
<ul>
<li>Consistancy
<ul>
<li>All the nodes/DBs must have same data simuntaniously</li>
<li>Say <code>write</code> is done on master node and <code>read</code> is done on slave DB</li>
<li>Now once <code>write</code> is done on <code>master</code> DB it takes time to update <code>slave</code> DB</li>
<li>If in between a user <code>reads</code> data so old value is returned this is <code>inconsistancy</code></li>
</ul>
</li>
<li>Availabity
<ul>
<li>From last case even if data is wrong but data is available, this is availability</li>
</ul>
</li>
<li>Partition Tolerance
<ul>
<li>Partition is communication break between two nodes</li>
<li>To have low tolerance to this partition the data update rate must be high. and this lag is partition tolerance</li>
</ul>
</li>
</ul>
</li>
<li>According to CAP theorm only two of these parameters can be achived at once
<ul>
<li>CA(Consistancy-Availability)
<ul>
<li>Two seperate node with high partition tolerancce and low C and A is not practical</li>
<li>This is possible when there is only one node, <code>not practically applicable for</code> <b><code>distributed DB</code></b></li>
</ul>
</li>
<li>CP(Consistancy-Partition Tolerance)
<ul>
<li>Here its okay if data is available late but data must be accurate</li>
<li>Say we are doing payment using UPI so there is lag 2-3sec sometime 10-15sec but bank balance is accurate</li>
<li>MongoDB</li>
</ul>
</li>
<li>AP(Availability-Pratition tolerance)
<ul>
<li>Here accuracy(Consistancy) is not that big deal</li>
<li>Eg. Facebook if number of likes decrease the data may take some time to update and the number of likes is always visible even if it is less or more</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="master-slave-configuration">Master Slave configuration</h1>
<ul>
<li>Master generally takes <code>write</code> requests</li>
<li>Slave generally takes <code>read</code> requests</li>
<li>Schema of master and slave may be different</li>
<li>
<img src="master_slave.png" width=500 />
</li>
<li>System may be syncronus or asyncronus</li>
</ul>

</body>
</html>
